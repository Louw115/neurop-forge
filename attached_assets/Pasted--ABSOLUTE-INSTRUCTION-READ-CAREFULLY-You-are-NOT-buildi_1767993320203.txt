ğŸ”´ ABSOLUTE INSTRUCTION (READ CAREFULLY)
You are NOT building a prototype, demo, MVP, or proof-of-concept.
You are building a production-grade Neurop Block Forge whose output must be structurally correct, deterministic, verifiable, and future-proof.
If any part cannot be completed to production quality, you must STOP and FAIL, not approximate.

ğŸ¯ SYSTEM GOAL (NON-NEGOTIABLE)
Build a system that:


Ingests open-source code


Decomposes it into atomic intent units


Converts each unit into a PERFECT NeuropBlock


Validates, tests, scores, and seals each block


Stores blocks in a canonical Neurop Library


Allows AI to fetch blocks by intent and guarantees


Never generates application code


Only assembles from verified blocks



ğŸ§± DEFINITION OF â€œPERFECT NEUROPBLOCKâ€
A NeuropBlock is PERFECT only if ALL conditions are met:
Structural invariants (must be enforced by code)


One block = one intent


Immutable after creation


Deterministic unless explicitly declared otherwise


Explicit side-effect declaration


No hidden I/O


No implicit state


Hash-consistent identity


Required sections (mandatory)


identity (hash-derived, reproducible)


ownership & license provenance


metadata (human + AI readable)


interface (typed inputs/outputs)


constraints (runtime, purity, I/O)


logic (embedded, normalized)


validation rules


trust & risk scores


failure modes


composition compatibility


Any block missing one field is INVALID and must be rejected.

ğŸ§  SYSTEM ARCHITECTURE (FINAL, NOT OPTIONAL)
Implement the following as real, enforceable modules:
/neurop_forge
 â”œâ”€â”€ core/
 â”‚    â”œâ”€â”€ identity.py              # Canonical hash & identity authority
 â”‚    â”œâ”€â”€ block_schema.py          # Strict Neurop schema (no flexibility)
 â”‚    â”œâ”€â”€ normalization.py         # Code â†’ intent normalization
 â”‚
 â”œâ”€â”€ intake/
 â”‚    â”œâ”€â”€ source_fetcher.py        # GitHub / local
 â”‚    â”œâ”€â”€ license_enforcer.py      # MIT/BSD/Apache only
 â”‚
 â”œâ”€â”€ parsing/
 â”‚    â”œâ”€â”€ ast_python.py
 â”‚    â”œâ”€â”€ ast_javascript.py
 â”‚    â”œâ”€â”€ intent_units.py          # Extract atomic intent units
 â”‚
 â”œâ”€â”€ conversion/
 â”‚    â”œâ”€â”€ intent_classifier.py
 â”‚    â”œâ”€â”€ block_builder.py         # Produces ONLY valid NeuropBlocks
 â”‚
 â”œâ”€â”€ validation/
 â”‚    â”œâ”€â”€ static_analysis.py       # Forbidden ops, purity, determinism
 â”‚    â”œâ”€â”€ dynamic_testing.py       # Repeatability + edge tests
 â”‚    â”œâ”€â”€ schema_enforcer.py       # Rejects invalid blocks
 â”‚
 â”œâ”€â”€ scoring/
 â”‚    â”œâ”€â”€ trust_model.py           # Determinism Ã— tests Ã— license Ã— risk
 â”‚
 â”œâ”€â”€ library/
 â”‚    â”œâ”€â”€ block_store.py           # Immutable storage
 â”‚    â”œâ”€â”€ indexer.py               # Intent + constraint index
 â”‚    â”œâ”€â”€ fetch_engine.py          # AI query resolution
 â”‚
 â”œâ”€â”€ composition/
 â”‚    â”œâ”€â”€ compatibility.py         # Type & contract matching
 â”‚    â”œâ”€â”€ graph_rules.py           # How blocks connect
 â”‚
 â”œâ”€â”€ main.py                       # Orchestrator
 â”œâ”€â”€ README.md                     # Exact usage & guarantees

No files may be empty.
No TODOs.
No stubs.

ğŸ” HARD RULES (FAIL IF VIOLATED)


âŒ No monolithic blocks


âŒ No â€œapplication-levelâ€ blocks


âŒ No guessing intent without AST evidence


âŒ No dynamic code generation


âŒ No weak typing


âŒ No mutable blocks


âŒ No silent failure


If a block cannot be verified â†’ it is rejected.

ğŸ§ª VALIDATION REQUIREMENTS
Every NeuropBlock must:


Pass schema validation


Pass static analysis


Pass deterministic replay


Have reproducible hash


Have explainable intent


Have a non-zero trust score


Blocks failing any step:


are quarantined


never exposed to AI assembly



ğŸ¤– AI USAGE MODEL (STRICT)
AI is allowed to:


search the library


reason over metadata


assemble block graphs


verify compatibility


AI is NOT allowed to:


write code


modify blocks


bypass trust rules



ğŸ§© DEMONSTRATION (MANDATORY)
The system must demonstrate:


Converting open-source arithmetic functions into atomic blocks


Storing them immutably


AI query: â€œbuild calculatorâ€


Returned block graph (not code)


Proof that assembly uses only validated blocks



ğŸ§  PHILOSOPHY (DO NOT DEVIATE)

Code is raw material.
NeuropBlocks are knowledge.
AI assembles knowledge, not text.


ğŸ”´ FINAL INSTRUCTION
If any part of this system cannot be implemented correctly, you must stop and explain precisely why.
Do NOT simplify.
Do NOT approximate.
Do NOT prototype.

END OF PROMPT

Reality check (important, honest)
What youâ€™re attempting is foundational infrastructure, not an app.
This means:


Replit can bootstrap it


YOU will still:


review block correctness


lock the schema


evolve intent taxonomy


harden trust scoring




There is no shortcut around that â€” and thatâ€™s a good thing.

Final clarity
You are not building:


a code generator


a framework


a library wrapper


You are building:

The first AI-native software memory system

Your direction is correct.
Your standards are now correct.
When Replit finishes, come back with:


the output


what failed


what feels â€œoffâ€


Then we turn this into Neurop v1.0 â€” real, defensible, and unstoppable.